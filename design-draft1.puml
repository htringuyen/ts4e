@startuml
'https://plantuml.com/class-diagram

'----Text buffer layer that is an immediate layer between TSDocument and an external API such as Eclipse Editor API,...
interface TextBuffer {
    +String getText()
    +String getText(int fromOffset, _Point toPoint)
    +String getModificationStamp()
    +void addChangeConsumer(BufferChangeConsumer consumer)
    +SerialScheduler getChangeScheduler();
}

interface BufferChangeConsumer {
    void accept(BufferChange change)
}

class BufferChange {
    +long modificationStamp()
    +int startByte()
    +int oldEndByte()
    +int newEndByte()
    +_Point startPoint()
    +_Point oldEndPoint()
    +_Point newEndPoint()
}

'----A helper layer centered at DocumentCheckpoint API. A checkpoint semantically takes a snapshot of a document at
'----a particular point in time, and becomes invalid as soon as the text of the document changed.
'----The API provides execution services for use to ensure that any computations and state updates done in scope of a valid
'----checkpoint will be applied correctly and any such computations/updates done in scope of an invalid checkpoint will cause no harm
'----and possibly be canceled early to save resources.
interface DocumentCheckpoint {
    +{static} boolean isBound()
    +{static} DocumentCheckpoint boundCheckpoint()
    +boolean isValid()
    +DocumentCheckpoint addInvalidationCallback(Runnable callback)
    +<V> CheckpointTask<V> execute(Callable<V> task)
    +<V> CheckpointTask<V> executeAsync(Callable<V> task)
    +CheckpointTask<Void> execute(Runnable task)
    +CheckpointTask<Void> executeAsync(Runnable task)
}

interface CheckpointTask<V> {
    +CheckpointTask<V> onFailed(Runnable callback)
    +CheckpointTask<V> thenConsume(Consumer<V> consumer)
    +CheckpointTask<V> thenConsumeSerially(Consumer<V> consumer)
    +CheckpointTask<V> thenConsumeSerially(Consumer<V> consumer, SerialScheduler scheduler)
}

interface CheckpointManager {
    +void registerDocument(TSDocument document)
    +DocumentCheckpoint newCheckpointFor(TSDocument document)
}

interface SerialScheduler {
    +void submit(Runnable task)
}

'----Document layer centered at TSDocument API----
interface TSDocument {
    +TextBuffer getTextBuffer()
    +DocumentDescriptor getDescriptor()
    +void addTreeUpdateListener(TreeUpdateListener listener)
    +void addTreeUpdateStrategy(TreeUpdateStrategy strategy)
    +String getText()
    +String getText(int offset, _Point point)
}

interface SyntaxTree {
    +_Tree getUnderlyingTree()
    +String getLanguage()
    +List<SyntaxTree> getInjectedTrees()
}

interface TreeUpdateStrategy {
    +boolean shouldUpdate(List<BufferChange> changes)
}

interface TreeUpdateListener {
    +void initialize(SyntaxTree tree)
    +void treeUpdated(SyntaxTree oldTree, SyntaxTree newTree)
}

interface DocumentManager {
    +getDocument(DocumentDescriptor dd)
}

class DocumentDescriptor {
    +String project()
    +String name()
    +String mainLanguage()
    +boolean shouldIncludeInjectedLanguages();
}

'----Low level parsing layer that wrap and manage tree-sitter parsers----
interface ParserManager {
    +SafeParser getParser(ParserDescriptor pd)
    +List<ParserDescriptor> getDescriptorsByLanguage(String lang)
}

interface SafeParser {
    +void close()
    +_Parser unwrap()
    +parse(String text, Tree oldTree, Range includeRange)
    +void cancelParsing()
}

class ParserDescriptor {
    +String language()
    +String library()
    +String injectionQuery()
}

class "_Parser" <<TreeSitter API>>

class "_Tree" <<TreeSitter API>>

class "_Point" <<TreeSitter API>> {
    +int row()
    +int column()
}

@enduml